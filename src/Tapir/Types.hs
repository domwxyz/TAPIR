{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}

module Tapir.Types
  ( -- * Core Types
    Role(..)
  , roleToText
  , textToRole
  , Message(..)
  , Session(..)
  , AnkiCard(..)

    -- * Errors
  , TapirError(..)
  , displayError
  , shortError

    -- * Re-exports
  , module Tapir.Types.Mode
  , module Tapir.Types.Language
  , module Tapir.Types.Provider
  ) where

import Data.Aeson
import Data.Text (Text)
import qualified Data.Text as T
import Data.Time (UTCTime)
import GHC.Generics (Generic)

-- Re-exports
import Tapir.Types.Mode
import Tapir.Types.Language
import Tapir.Types.Provider

-- ════════════════════════════════════════════════════════════════
-- ROLE
-- ════════════════════════════════════════════════════════════════

-- | Message role in conversation
data Role = User | Assistant | System
  deriving (Eq, Show, Generic)

instance ToJSON Role where
  toJSON = \case
    User      -> "user"
    Assistant -> "assistant"
    System    -> "system"

instance FromJSON Role where
  parseJSON = withText "Role" $ \case
    "user"      -> pure User
    "assistant" -> pure Assistant
    "system"    -> pure System
    other       -> fail $ "Unknown role: " <> T.unpack other

-- | Convert Role to Text for database storage
roleToText :: Role -> Text
roleToText = \case
  User      -> "user"
  Assistant -> "assistant"
  System    -> "system"

-- | Parse Role from Text
textToRole :: Text -> Maybe Role
textToRole = \case
  "user"      -> Just User
  "assistant" -> Just Assistant
  "system"    -> Just System
  _           -> Nothing

-- ════════════════════════════════════════════════════════════════
-- MESSAGE
-- ════════════════════════════════════════════════════════════════

-- | Chat message (stored in database)
-- Note: ID is auto-generated by SQLite (INTEGER PRIMARY KEY AUTOINCREMENT)
data Message = Message
  { messageId         :: !(Maybe Int)  -- Nothing for new messages, Just for persisted
  , messageSessionId  :: !Text         -- UUID as text
  , messageRole       :: !Role
  , messageContent    :: !Text
  , messageMode       :: !Mode         -- The mode this message was sent in
  , messageTimestamp  :: !UTCTime
  , messageModel      :: !(Maybe Text) -- Model used for assistant messages
  , messageProvider   :: !(Maybe Text) -- Provider used
  , messageTokensUsed :: !(Maybe Int)  -- Token count if available
  , messageError      :: !(Maybe Text) -- Error message if response failed
  } deriving (Eq, Show, Generic)

instance ToJSON Message
instance FromJSON Message

-- ════════════════════════════════════════════════════════════════
-- SESSION
-- ════════════════════════════════════════════════════════════════

-- | Conversation session
-- Note: ID is a UUID v4 stored as text
data Session = Session
  { sessionId          :: !Text         -- UUID v4 as text
  , sessionLanguageId  :: !Text
  , sessionMode        :: !Mode
  , sessionLearnerLevel :: !LearnerLevel
  , sessionCreatedAt   :: !UTCTime
  , sessionUpdatedAt   :: !UTCTime
  , sessionTitle       :: !(Maybe Text)
  , sessionActive      :: !Bool
  } deriving (Eq, Show, Generic)

instance ToJSON Session
instance FromJSON Session

-- ════════════════════════════════════════════════════════════════
-- ANKI CARD
-- ════════════════════════════════════════════════════════════════

-- | Anki flashcard
-- Note: ID is auto-generated by SQLite (INTEGER PRIMARY KEY AUTOINCREMENT)
data AnkiCard = AnkiCard
  { cardId          :: !(Maybe Int)    -- Nothing for new cards, Just for persisted
  , cardSessionId   :: !Text           -- FK to session
  , cardLanguageId  :: !Text
  , cardFront       :: !Text
  , cardBack        :: !Text
  , cardTags        :: ![Text]         -- Stored as JSON array in DB
  , cardDeck        :: !Text
  , cardSourceMsgId :: !(Maybe Int)    -- Source message that generated this card
  , cardAnkiNoteId  :: !(Maybe Integer) -- AnkiConnect note ID after push
  , cardPushedAt    :: !(Maybe UTCTime) -- When pushed to Anki
  , cardCreatedAt   :: !UTCTime
  } deriving (Eq, Show, Generic)

instance ToJSON AnkiCard
instance FromJSON AnkiCard

-- ════════════════════════════════════════════════════════════════
-- ERRORS
-- ════════════════════════════════════════════════════════════════

-- | All possible errors in TAPIR
data TapirError
  -- Config errors
  = ConfigNotFound FilePath
  | ConfigParseError FilePath Text
  | LanguageNotFound Text
  | InvalidLanguageConfig Text Text  -- language, reason

  -- LLM errors
  | APIKeyMissing
  | APIError Int Text                -- status code, message
  | NetworkError Text
  | StreamingError Text
  | ModelNotAvailable Text
  | RateLimitExceeded Int            -- retry after seconds

  -- Database errors
  | DatabaseError Text
  | SessionNotFound Text             -- session ID
  | MigrationError Int Text          -- version, reason

  -- Anki errors
  | AnkiNotRunning
  | AnkiConnectionError Text
  | DeckNotFound Text
  | CardParseError Text

  -- Prompt errors
  | PromptTemplateError Text
  | MissingPromptVariable Text

  -- General errors
  | InternalError Text
  deriving (Eq, Show)

-- | User-friendly error messages
displayError :: TapirError -> Text
displayError = \case
  ConfigNotFound path ->
    "Configuration file not found: " <> T.pack path
  ConfigParseError path reason ->
    "Failed to parse config at " <> T.pack path <> ": " <> reason
  LanguageNotFound lang ->
    "Language '" <> lang <> "' not found. Run 'tapir --list-languages' to see available."
  InvalidLanguageConfig lang reason ->
    "Invalid config for language '" <> lang <> "': " <> reason

  APIKeyMissing ->
    "API key not set. Set OPENROUTER_API_KEY environment variable or add to config."
  APIError code msg ->
    "API error (" <> T.pack (show code) <> "): " <> msg
  NetworkError msg ->
    "Network error: " <> msg <> ". Check your internet connection."
  StreamingError msg ->
    "Streaming error: " <> msg
  ModelNotAvailable model ->
    "Model '" <> model <> "' not available. Check your provider settings."
  RateLimitExceeded secs ->
    "Rate limit exceeded. Retry after " <> T.pack (show secs) <> " seconds."

  DatabaseError msg ->
    "Database error: " <> msg
  SessionNotFound sid ->
    "Session not found: " <> sid
  MigrationError ver reason ->
    "Database migration to version " <> T.pack (show ver) <> " failed: " <> reason

  AnkiNotRunning ->
    "Anki is not running or AnkiConnect is not installed."
  AnkiConnectionError msg ->
    "Failed to connect to Anki: " <> msg
  DeckNotFound deck ->
    "Anki deck '" <> deck <> "' not found."
  CardParseError msg ->
    "Failed to parse card from response: " <> msg

  PromptTemplateError msg ->
    "Prompt template error: " <> msg
  MissingPromptVariable var ->
    "Missing variable in prompt template: " <> var

  InternalError msg ->
    "Internal error: " <> msg <> ". This is a bug."

-- | Short error messages for status bar
shortError :: TapirError -> Text
shortError = \case
  APIKeyMissing        -> "API key missing"
  APIError code _      -> "API error " <> T.pack (show code)
  NetworkError _       -> "Network error"
  RateLimitExceeded _  -> "Rate limited"
  AnkiNotRunning       -> "Anki not running"
  DatabaseError _      -> "Database error"
  _                    -> "Error (see logs)"
